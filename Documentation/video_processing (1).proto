// ============================================================================
//  Обзор протокола Video Processing Protocol Buffers (proto3)
// ============================================================================
//
//  Назначение
//  ----------------------------------------------------------------------------
//  Данный файл .proto определяет структуры данных (сообщения) и перечисления,
//  используемые для передачи видео-кадров между компонентами распределенной
//  системы обработки видео в реальном времени.
//
//  Система построена по конвейерной (pipeline) архитектуре и включает три
//  основных типа компонентов:
//      1. **Capturer**   – захват исходных кадров из источника (камера, файл, поток).
//      2. **Worker**     – обработка кадра (например, детекция объектов, фильтрация).
//      3. **Composer**   – компоновка исходного и обработанного кадров в выходное видео.
//
//  Основные сущности
//  ----------------------------------------------------------------------------
//  * **FrameType**     – определяет тип кадра (захваченный/обработанный) и его маршрут.
//  * **PixelFormat**   – цветовой формат пикселей (RGB, BGR, GRAY).
//  * **ImageEncoding** – формат кодирования изображения (JPEG, PNG, BMP, RAW).
//  * **ImageData**     – универсальный контейнер для одного изображения с метаданными.
//  * **ImagePair**     – пара изображений (исходное + обработанное) для передачи от Worker к Composer.
//  * **VideoFrame**    – основное сообщение для передачи кадров по конвейеру. Содержит общие метаданные
//                        и объединение (oneof) для гибкого хранения либо одного изображения, либо пары.
//
//  Типовой поток данных
//  ----------------------------------------------------------------------------
//  1. Capturer создает VideoFrame с frame_type = CAPTURED_FRAME, заполняет single_image
//     (ImageData с исходным кадром) и отправляет его Worker-у.
//  2. Worker получает VideoFrame, обрабатывает single_image, создает новое VideoFrame
//     с frame_type = PROCESSED_FRAME, заполняет image_pair (ImagePair, содержащий
//     оригинальное и обработанное изображения) и отправляет его Composer-у.
//  3. Composer получает VideoFrame, извлекает image_pair и использует оба изображения
//     для формирования итогового видео.
//
//  Важные замечания
//  ----------------------------------------------------------------------------
//  1. Согласованность полей:
//     - При frame_type = CAPTURED_FRAME должно быть заполнено поле single_image.
//     - При frame_type = PROCESSED_FRAME должно быть заполнено поле image_pair.
//     Логика проверки этой согласованности должна быть реализована в коде приложения.
//
//  2. Форматы данных:
//     - Поле ImageData.image_data содержит бинарные данные изображения, интерпретация
//       которых определяется полями pixel_format и encoding.
//     - Для эффективной передачи рекомендуется использовать сжатые форматы (JPEG, PNG),
//       особенно для полей single_image и processed внутри ImagePair.
//
//  3. Идентификаторы:
//     - frame_id должен монотонно увеличиваться в рамках одного потока от Capturer.
//     - timestamp рекомендуется устанавливать в момент захвата кадра с максимальной
//       доступной точностью.
//     - sender_id помогает в отладке и трассировке сообщений в распределенной системе.
//
//  Примеры использования
//  ----------------------------------------------------------------------------
//  См. примеры сериализации/десериализации и заполнения структур в директории /examples
//  репозитория или в документации к SDK.
//
//  Поддерживаемые версии
//  ----------------------------------------------------------------------------
//  - Язык: Protocol Buffers версии 3 (proto3)
//  - Кодировка: Стандартная binary format для сериализации.
//  - Поддерживаемые языки для генерации кода: C++, C#, Go, Java, Python, Rust и др.
//
//  Автор и лицензия
//  ----------------------------------------------------------------------------
//  Автор: Команда разработки VideoProcessing
//  Лицензия: Проприетарная (или подставьте актуальную, например, MIT).
//  Дата последнего обновления: 2024-05-17
//
// ============================================================================


syntax = "proto3";

package video_processing;

// ============================================================================
//  Общие перечисления (Enums)
// ============================================================================

/**
 * @enum FrameType
 * @brief Определяет тип кадра для маршрутизации между компонентами системы.
 * @var FrameType::CAPTURED_FRAME
 *      Исходный, захваченный кадр. Передается от Capturer к Worker.
 * @var FrameType::PROCESSED_FRAME
 *      Обработанный кадр. Передается от Worker к Composer.
 */
enum FrameType {
    CAPTURED_FRAME = 0;    ///< Capturer → Worker
    PROCESSED_FRAME = 1;   ///< Worker → Composer
}

/**
 * @enum PixelFormat
 * @brief Определяет формат хранения цвета для пиксельных данных.
 * @var PixelFormat::RGB  Порядок цветовых каналов: Красный, Зеленый, Синий.
 * @var PixelFormat::BGR  Порядок цветовых каналов: Синий, Зеленый, Красный (для OpenCV).
 * @var PixelFormat::GRAY Одноканальное изображение в оттенках серого.
 */
enum PixelFormat {
    RGB = 0;   ///< Формат RGB
    BGR = 1;   ///< Формат BGR
    GRAY = 2;  ///< Одноканальное изображение (оттенки серого)
}

/**
 * @enum ImageEncoding
 * @brief Определяет алгоритм кодирования/сжатия для изображения.
 * @var ImageEncoding::JPEG Сжатие с потерями. Для фотографий.
 * @var ImageEncoding::PNG  Сжатие без потерь. Поддерживает прозрачность.
 * @var ImageEncoding::BMP  Формат без сжатия (RAW) в контейнере BMP.
 * @var ImageEncoding::RAW  Несжатые пиксельные данные в чистом виде.
 */
enum ImageEncoding {
    JPEG = 0;  ///< Сжатие JPEG (с потерями)
    PNG = 1;   ///< Сжатие PNG (без потерь)
    BMP = 2;   ///< Формат BMP (обычно без сжатия)
    RAW = 3;   ///< Несжатые "сырые" данные пикселей
}

// ============================================================================
//  Основные структуры данных (Messages)
// ============================================================================

/**
 * @struct ImageData
 * @brief Контейнер для чистых пиксельных данных изображения и его технических параметров.
 * @details Используется как самостоятельный объект для передачи одного изображения,
 *          а также как часть ImagePair. Содержит метаданные, необходимые для
 *          корректной интерпретации бинарного блока `image_data`.
 *
 * @var ImageData::width        Ширина изображения в пикселях. Тип: uint32.
 * @var ImageData::height       Высота изображения в пикселях. Тип: uint32.
 * @var ImageData::pixel_format Цветовой формат пикселей (RGB, BGR, GRAY). Тип: PixelFormat.
 * @var ImageData::encoding     Способ кодирования данных изображения (JPEG, PNG, BMP, RAW). Тип: ImageEncoding.
 * @var ImageData::image_data
 *      Бинарный буфер, содержащий закодированные пиксельные данные изображения.
 *      Интерпретация зависит от полей `pixel_format` и `encoding`. Тип: bytes.
 */
message ImageData {
    uint32 width = 1;          ///< Ширина изображения (пиксели)
    uint32 height = 2;         ///< Высота изображения (пиксели)
    PixelFormat pixel_format = 3; ///< Цветовой формат пикселей
    ImageEncoding encoding = 4;   ///< Формат кодирования изображения
    bytes image_data = 5;      ///< Закодированные данные изображения
}

/**
 * @struct ImagePair
 * @brief Пара изображений: исходное и обработанное.
 * @details Используется исключительно для передачи данных от компонента Worker
 *          к компоненту Composer. Worker создает эту пару после обработки кадра,
 *          Composer читает ее для последующего сжатия в видео.
 *
 * @var ImagePair::original  Исходное изображение, полученное от Capturer. Тип: ImageData.
 * @var ImagePair::processed Результат обработки, сгенерированный Worker. Тип: ImageData.
 */
message ImagePair {
    ImageData original = 1;    ///< Исходное (захваченное) изображение
    ImageData processed = 2;   ///< Обработанное изображение
}

/**
 * @struct VideoFrame
 * @brief Универсальный контейнер для передачи видео-кадров между компонентами системы.
 * @details Содержит общие метаданные кадра и `oneof` поле `content` для гибкого
 *          хранения разных типов данных в зависимости от этапа конвейера.
 *          Поле `frame_type` указывает тип содержимого и направление передачи.
 *
 * @var VideoFrame::frame_id
 *      Уникальный последовательный идентификатор кадра в рамках потока.
 *      Используется для синхронизации и логирования. Тип: uint64.
 * @var VideoFrame::timestamp
 *      Временная метка захвата кадра в секундах (с дробной частью).
 *      Тип: double.
 * @var VideoFrame::sender_id
 *      Идентификатор компонента-отправителя (например, "capturer_01", "worker_gpu_02").
 *      Тип: string.
 * @var VideoFrame::frame_type
 *      Тип кадра, определяющий смысл содержимого и маршрут.
 *      @see FrameType. Тип: FrameType.
 *
 * @var VideoFrame::content
 *      Поле объединения (`oneof`), которое содержит либо одно изображение, либо пару.
 *      Одно из полей должно быть заполнено:
 *      - **single_image**: Одно изображение. Должно использоваться с `frame_type = CAPTURED_FRAME`.
 *          Направление: **Capturer → Worker** (Capturer создает, Worker читает).
 *      - **image_pair**: Пара изображений. Должно использоваться с `frame_type = PROCESSED_FRAME`.
 *          Направление: **Worker → Composer** (Worker создает, Composer читает).
 *      @note Разработчик должен явно проверять эту согласованность между `frame_type` и `content` в коде.    
 */
message VideoFrame {
    // ----- Общие данные (Common Metadata) -----
    uint64 frame_id = 1;      ///< Уникальный ID кадра в потоке
    double timestamp = 2;     ///< Метка времени захвата (секунды)
    string sender_id = 3;     ///< ID компонента-отправителя
    FrameType frame_type = 4; ///< Тип кадра (определяет содержимое и маршрут)

    // ----- Данные кадра (Frame Data) -----
    oneof content {
        ImageData single_image = 5; ///< Одно изображение. Должно использоваться для Capturer → Worker.
        ImagePair image_pair = 6;   ///< Пара изображений. Должно использоваться для Worker → Composer.
    }
}